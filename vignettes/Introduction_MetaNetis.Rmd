---
title: "Introduction_MetaNetis"
date: "`r format(Sys.time(), '%d %b %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction_MetaNetis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(MetaNetis)
library(knitr)
library(dplyr)
```

## Introduction

MetaNetis is an $\text{R}$ package designed to bridge the gap between raw metabolomics data and deep biological interpretation. It provides a standardized framework for benchmarking user-supplied metabolite concentrations against a robust, healthy human reference population derived from resources like the Human Metabolome Database ($\text{HMDB}$).

The package's core value lies in its ability to generate high-confidence classifications and translate those classifications into functional insights about metabolic pathway activity.

Critically, MetaNetis offers robust functionality to evaluate quantitative, clinical sampled data such as blood and urine. This capability is a key differentiator from existing tools; for instance, popular platforms like MetaboAnalyst are often restricted to qualitative analysis, relying solely on pathway enrichment. MetaNetis moves beyond simple enrichment to provide a direct, directional assessment of metabolic activity (e.g., hyper- or hypo-regulation), making it a powerful tool for metabolomic and clinical research.

This document gives a tour of MetaNetis (version 0.1.0). It was written in R Markdown, using the knitr package for production. See help(package = "MetaNetis") for further details.

![MetaNetis Package Overview](package_overview.png){width=600px}

<br>

To download **MetaNetis**, use the following commands:

``` {r}
require("devtools")
devtools::install_github("dujay971226/MetaNetis", build_vignettes = TRUE)
library("MetaNetis")
```

To list all sample functions available in the package:

``` {r}
ls("package:MetaNetis")
```

To list all sample datasets available in the package:

``` {r}
data(package = "MetaNetis")
```

<br>

## Applications

Let's started with viewing reference metabolite range:

```{r}
ref_df <- MetaNetis::GetRefRanges()
head(ref_df)
```

<br>

This reference data was generated by aggregating metabolite range from healthy human samples.
If you wish to use another reference range, feel free to use SetAltBaseline(your_data)
your_data can be either a csv path or a data frame.

Next, we will mock a metabolite sample dataset:

``` {r}
# Make a mock reference data
mock_reference_data <- data.frame(
 'HMDB_ID' = c("HMDB0000001", "HMDB0000001", "HMDB0000002", "HMDB0000003", "HMDB0000005"),
 'Metabolite_Name' = c("Alanine", "Alanine", "Glucose", "Creatinine", "Missing_Metab"),
 'Sample_Type' = c("Urine", "Plasma", "Plasma", "Urine", "Plasma"),
 'Min_Age(year)' = c(0, 11, 0, 0, 0),
 'Max_Age(year)' = c(99, 99, 99, 99, 99),
 'Min_Concentration(Healthy)' = c(500, 150, 4.0, 50, 200),
 'Max_Concentration(Healthy)' = c(1000, 300, 7.0, 100, 400),
 check.names = FALSE
)

# User's Input
user_data <- data.frame(
 Sample_A = c(250, 6.0, 120, 50),
 Sample_B = c(160, 12.0, 60, 50),
 row.names = c("HMDB0000001", "HMDB0000002", "HMDB0000003", "HMDB0000004")
)

# Age and Sample Type
age_vector <- c(5, 20)
sample_type_vector <- c("Urine", "Plasma") # Sample A is Urine, Sample B is Plasma

```

<br>

Then, we will run that through MetabAnalysis, which classifies metabolite level
based on the reference HMDB range:

```{r}
# Test Case: Matching by HMDB_ID
results_id <- MetaNetis::MetabAnalysis(
 data_input = user_data,
 age = age_vector,
 sample_type = sample_type_vector,
 match_by = "HMDB_ID",
 ref_data_override = mock_reference_data
)

print(results_id)
```
For Sample A, as the age range is 11+, 5 year old a can't match a range for 0000002
as for 0000004, it wasn't in the mock reference data frame at all. 
Hence, [Low, Missing, High, Missing].

<br>

As the dataset size is too small to show a network, I will be creating another set
of mock data:

``` {r}
# Mock reference data and samples
metab_to_pwys <- data.frame(
  Metabolite_Name = c("Glucose", "Fructose", "Lactate", "Pyruvate",
                      "Cholesterol", "Leucine", "Valine", "Isoleucine",
                      "Tryptophan", "Serotonin"),
  HMDB_ID = c("HMDB00001", "HMDB00002", "HMDB00003", "HMDB00004",
              "HMDB00005", "HMDB00006", "HMDB00007", "HMDB00008",
              "HMDB00009", "HMDB00010"),
  Pathway_Name = c("Glycolysis", "Glycolysis", "Energy Metabolism",
                   "Energy Metabolism", "Lipid Metabolism", "BCAA Metabolism",
                   "BCAA Metabolism", "BCAA Metabolism", "Serotonin Synthesis",
                   "Serotonin Synthesis"),
  stringsAsFactors = FALSE
)

# Assign the object to the global environment, so the internal helper function
# can find it (simulating loaded package data).
assign("metab_to_pwys", metab_to_pwys, envir = .GlobalEnv)

# Create input data where metabolite names are in the row names, simulating
# the typical output from metab_results.
metabolites <- c("Glucose", "Fructose", "Lactate", "Pyruvate",
                 "Cholesterol", "Leucine", "Valine", "Isoleucine",
                 "Tryptophan", "Serotonin", "Unmapped Metabolite")

metab_results <- data.frame(
  Sample1 = c("Low", "Low", "High", "High", "Normal", "High", "Normal", "High", "Low", "Normal", "High"),
  Sample2 = c("High", "Low", "Normal", "High", "Low", "Normal", "High", "High", "Normal", "Low", "Low"),
  Sample3 = c("Normal", "Low", "High", "Normal", "Low", "Normal", "Normal", "High", "High", "High", "Normal"),
  stringsAsFactors = FALSE
)

# Assign metabolite names as row names directly, as required by the function
rownames(metab_results) <- metabolites
```

Then we can run our mapping:

``` {r}
result <- MapToPathway(metab_results, match_by = "Metabolite_Name")
result
```


Net_Score was calculated by summing over metabolite abundance:
if within that pathway, metabolite is "Low", it will respresent a -1 on Net_score
Same as "High" for +1. Missing and Normal will simply be +0. The more metabolites
expressed in that pathway, the more active it is.

<br>

Lastly, Let's try plotting the Network with a new mock dataset:

```{r}
# Define 12 pathways
pathways <- c(
  "Glycolysis", "Energy Metabolism", "Lipid Metabolism",
  "BCAA Metabolism", "Serotonin Synthesis", "Histidine Metabolism",
  "TCA Cycle", "Purine Metabolism", "Pyrimidine Metabolism",
  "Fatty Acid Oxidation", "Amino Acid Metabolism", "Urea Cycle"
)

# Create 50 metabolites
metabolites <- paste0("Metab", 1:50)
hmdb_ids <- paste0("HMDB", sprintf("%05d", 1:50))

# Each metabolite participates in 2-4 random pathways to create dense connections
metab_to_pwys <- tibble::tibble()
for (i in 1:50) {
  n_paths <- sample(2:4, 1)
  temp <- tibble::tibble(
    Metabolite_Name = rep(metabolites[i], n_paths),
    HMDB_ID = rep(hmdb_ids[i], n_paths),
    Pathway_Name = sample(pathways, n_paths)
  )
  metab_to_pwys <- dplyr::bind_rows(metab_to_pwys, temp)
}

# Mock pathway results per sample
  result <- expand.grid(
    Sample_ID = c("Sample1", "Sample2"),
    Pathway_Name = pathways
  ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(
      Net_Score = sample(-3:3, n(), replace = TRUE),
      Metabolites_Affected = sample(1:10, n(), replace = TRUE),
      Activity_Status = sample(c(
        "Hyperactive", "Normal Activity", "Hypoactive", "Mild Inhibition"
      ), n(), replace = TRUE)
    )
```

Now Plot!

``` {r, fig.width=10, fig.height=8, out.width='600px'}
PlotNetwork(result, "Sample1")
```

each node is a pathway, and an edge connects two pathways if they share at least
one metabolite. Node color is determined by pathway Net_Score: (red = hyperactive, blue = hypoactive).

<br>

## Package References

- Jay, D. (2025) MetaNetis: Pathway activity networks analysis based on metabolite abundance. Unpublished. https://github.com/dujay971226/MetaNetis

<br>

## Other Reference

- Csardi, G., & Nepusz, T. (2006). The igraph software package for complex network research. InterJournal, Complex Systems, 1695.

- Google. (2025). Gemini.

- Müller, K., & Wickham, H. (2023). tibble: Simple data frames (Version 3.2.1). https://tibble.tidyverse.org/

- Pedersen, T. L. (2022). ggraph: An implementation of grammar of graphics for graphs (Version 2.1.0). https://ggraph.data-imaginist.com

- R Core Team. (2024). R: A language and environment for statistical computing. R Foundation for Statistical Computing. https://www.R-project.org/

- Wickham, H. (2016). ggplot2: Elegant graphics for data analysis. Springer-Verlag.

- Wickham, H., François, R., Henry, L., & Müller, K. (2023). dplyr: A grammar of data manipulation (Version 1.1.3). https://dplyr.tidyverse.org/

- Wickham, H., & Hester, J. (2024). stringr: Simple, consistent string routines (Version 1.5.1) [R package]. https://stringr.tidyverse.org/

- Wickham, H., & Ruiz, M. (2023). tidyr: Tidy messy data (Version 1.3.0). https://tidyr.tidyverse.org/

- Wishart, D. S., et al. (2022). HMDB 5.0: The Human Metabolome Database for 2022. Nucleic Acids Research, 50(D1), D218–D227. https://hmdb.ca/


``` {r}
sessionInfo()
```
